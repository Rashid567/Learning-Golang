/*
Что выведет программа?

Объяснить поведение срезов при передаче их в функцию.
*/
package main

import (
	"fmt"
)

func main() {
	var s = []string{"1", "2", "3"}
	modifySlice(s)
	fmt.Println(s)
}

func modifySlice(i []string) {
	i[0] = "3"
	i = append(i, "4")
	i[1] = "5"
	i = append(i, "6")
}

/*
ОТВЕТ

Вывод программы:
```
[3, 2, 3]
```


Структура слайса/среза:
type slice struct {
	array unsafe.Pointer // Указатель на массив
	len   int            // Длина слайса
	cap   int            // Вместимость слайса
}


Объяснение:

Строка 13
Создаём слайс строк
s = [1, 2, 3]  // len=3, cap=3

Строка 14
Вызываем функцию modifySlice и передаём в неё слайс.
При этом копируется структура слайса, но не сам массив на который ссылается слайс (array).
s = [1, 2, 3]  // len=3, cap=3
i = [1, 2, 3]  // len=3, cap=3

Строка 19
Меняем первый элемент массива
s = [3, 2, 3]  // len=3, cap=3
i = [3, 2, 3]  // len=3, cap=3

Строка 20
Добавляем `4` в слайс. Go создаёт новый массив и в него добавляет `4`, так как у текущего len == cap.
С этого момента функция оперирует новым массивом и старый не изменяется
s = [3, 2, 3]     // len=3, cap=3
i = [3, 2, 3, 4]  // len=4, cap=6

Строка 21
Меняем 2 элемент у нового массива
s = [3, 2, 3]     // len=3, cap=3
i = [3, 5, 3, 4]  // len=4, cap=6

Строка 22
К новому массиву добавляем `6`
s = [3, 2, 3]        // len=3, cap=3
i = [3, 5, 3, 4, 6]  // len=5, cap=6

Строка 15
Распечатываем исходный слайс
s = [3, 2, 3]        // len=3, cap=3

*/
