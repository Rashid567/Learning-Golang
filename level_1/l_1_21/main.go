/*
Паттерн «Адаптер»
Реализовать паттерн проектирования «Адаптер» на любом примере.

Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.

Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой,
несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс
и делегирует вызовы к встроенному объекту.

Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.
*/

/*
ОТВЕТ

Когда применять:
1. Когда класс нельзя трогать, но нужно подружить его с чем либо
2. Когда нужно заставить работать несколько классов вместе

Плюсы:
1. Позволяет не модифицировать исходный класс/классы
2. Скрывает реализацию от клиентов

Минусы:
1. Усложнение кода
2. Накладные ресурсы на вызов посредника/адаптера
*/

package main

import (
	"fmt"
)

type Human struct {
	name string
}

func (h *Human) SayHello() string {
	return "Hello!"
}

type Speakable interface {
	Speak() string
}

type Adapter struct {
	Human
}

func (a *Adapter) Speak() string {
	return a.SayHello()
}

func makeSpeak(object Speakable) {
	fmt.Println(object.Speak())
}

func main() {
	human := Human{"Shrek"}
	humanAdapter := Adapter{Human: human}
	makeSpeak(&humanAdapter)
}
